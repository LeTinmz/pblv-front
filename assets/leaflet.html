<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
    }
    .leaflet-popup-content {
      margin: 8px;
    }
    .leaflet-popup-content h3 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ===== INITIALISATION DE LA CARTE =====
    const map = L.map('map', { zoomControl: true }).setView([45.71301, 5.12916], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, 
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // ===== VARIABLES GLOBALES =====
    let meMarker = null;
    let meCircle = null;
    let firstFixDone = false;
    
    // Groupes de markers
    const collectCenterMarkers = L.layerGroup().addTo(map);
    const binMarkers = L.layerGroup().addTo(map);
    
    // Stockage des r√©f√©rences
    const centerMarkersById = {};
    const binMarkersById = {};

    // √âtat des filtres
    let showCenters = true;
    let showBins = true;

    // ===== IC√îNES PERSONNALIS√âES =====
    
    // Ic√¥ne utilisateur (bleue)
    const userIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // Ic√¥ne centres de collecte (verte)
    const collectCenterIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // Fonction pour obtenir l'ic√¥ne selon le type de d√©chet
    function getBinIcon(garbageType) {
      let color = 'red'; // Par d√©faut
      
      if (garbageType) {
        const type = garbageType.toLowerCase();
        if (type.includes('verre')) color = 'green';
        else if (type.includes('plastique') || type.includes('jaune')) color = 'yellow';
        else if (type.includes('papier') || type.includes('carton')) color = 'blue';
        else if (type.includes('m√©tal')) color = 'grey';
        else if (type.includes('organique') || type.includes('bio')) color = 'orange';
      }
      
      return L.icon({
        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [20, 33],
        iconAnchor: [10, 33],
        popupAnchor: [1, -30],
        shadowSize: [33, 33]
      });
    }

    // ===== FONCTIONS POUR LA POSITION UTILISATEUR =====
    
    function updateMe(lat, lng, accuracy) {
      const latlng = [lat, lng];

      if (!meMarker) {
        meMarker = L.marker(latlng, { 
          icon: userIcon,
          title: "Ma position" 
        }).addTo(map);
        meMarker.bindPopup("<b>Vous √™tes ici</b>");
      } else {
        meMarker.setLatLng(latlng);
      }

      if (!meCircle) {
        meCircle = L.circle(latlng, { 
          radius: accuracy || 20,
          color: '#3388ff',
          fillColor: '#3388ff',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(map);
      } else {
        meCircle.setLatLng(latlng);
        if (accuracy) meCircle.setRadius(accuracy);
      }

      if (!firstFixDone) {
        map.flyTo(latlng, 13, { duration: 1 });
        firstFixDone = true;
      }
    }

    // ===== FONCTIONS POUR LES CENTRES DE COLLECTE =====
    
    function createCenterPopupContent(center) {
      let html = '<div style="min-width: 200px; max-width: 300px;">';
      html += `<h3 style="margin: 0 0 8px 0; font-size: 16px; color: #2c3e50;">${center.name}</h3>`;
      
      if (center.address) {
        html += `<p style="margin: 4px 0; font-size: 13px; color: #555;">`;
        html += `<strong>üìç Adresse:</strong><br/>${center.address}</p>`;
      }
      
      if (center.community) {
        html += `<p style="margin: 4px 0; font-size: 13px; color: #555;">`;
        html += `<strong>üèòÔ∏è Communaut√©:</strong> ${center.community}</p>`;
      }
      
      if (center.garbageTypes && center.garbageTypes.length > 0) {
        html += `<p style="margin: 4px 0; font-size: 13px; color: #555;">`;
        html += `<strong>‚ôªÔ∏è Types de d√©chets:</strong><br/>`;
        center.garbageTypes.forEach(type => {
          html += `<span style="display: inline-block; background: #e8f5e9; padding: 2px 6px; margin: 2px; border-radius: 3px; font-size: 11px;">${type}</span>`;
        });
        html += '</p>';
      }
      
      if (center.website) {
        html += `<p style="margin: 8px 0 0 0;">`;
        html += `<a href="${center.website}" target="_blank" style="color: #27ae60; text-decoration: none; font-weight: 500;">`;
        html += `üîó Visiter le site web ‚Üí</a></p>`;
      }
      
      html += '</div>';
      return html;
    }

    function addCollectCenter(center) {
      if (!center.latitude || !center.longitude) {
        console.warn('Centre sans coordonn√©es:', center.name);
        return;
      }

      const lat = parseFloat(center.latitude);
      const lng = parseFloat(center.longitude);

      if (isNaN(lat) || isNaN(lng)) {
        console.warn('Coordonn√©es invalides pour:', center.name);
        return;
      }

      const latlng = [lat, lng];
      const popupContent = createCenterPopupContent(center);

      if (centerMarkersById[center.id]) {
        centerMarkersById[center.id]
          .setLatLng(latlng)
          .setPopupContent(popupContent);
      } else {
        const marker = L.marker(latlng, { 
          icon: collectCenterIcon,
          title: center.name 
        })
          .bindPopup(popupContent);
        
        collectCenterMarkers.addLayer(marker);
        centerMarkersById[center.id] = marker;
      }
    }

    // ===== FONCTIONS POUR LES BINS =====
    
    function createBinPopupContent(bin) {
      let html = `<div style="min-width: 180px; max-width: 280px;">
        <h3 style="margin: 0 0 8px 0; font-size: 15px; color: #2c3e50;">üóëÔ∏è Poubelle</h3>`;
      
      if (bin.garbageType) {
        const colorMap = {
          'verre': '#4CAF50',
          'plastique': '#FFC107',
          'papier': '#2196F3',
          'm√©tal': '#9E9E9E',
          'organique': '#795548',
          'g√©n√©ral': '#607D8B'
        };
        
        const garbageTypeLower = bin.garbageType.toLowerCase();
        let color = '#666';
        
        for (const key in colorMap) {
          if (garbageTypeLower.includes(key)) {
            color = colorMap[key];
            break;
          }
        }
        
        html += `<p style="margin: 6px 0; font-size: 13px;">
          <strong>‚ôªÔ∏è Type:</strong> 
          <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: 600;">
            ${bin.garbageType}
          </span>
        </p>`;
      }
      
      if (bin.community) {
        html += `<p style="margin: 4px 0; font-size: 12px; color: #666;">
          <strong>üèòÔ∏è Communaut√©:</strong> ${bin.community}
        </p>`;
      }
      
      html += `<p style="margin: 6px 0 0 0; font-size: 11px; color: #999;">
        üìç ${parseFloat(bin.latitude).toFixed(5)}, ${parseFloat(bin.longitude).toFixed(5)}
      </p>`;
      
      if (bin.qrCode) {
        html += `<p style="margin: 8px 0 0 0; padding-top: 6px; border-top: 1px solid #eee;">
          <a href="${bin.qrCode}" target="_blank" style="color: #2196F3; text-decoration: none; font-size: 12px; font-weight: 500;">
            üì± QR Code ‚Üí
          </a>
        </p>`;
      }
      
      html += '</div>';
      return html;
    }

    function addBin(bin) {
      if (!bin.latitude || !bin.longitude) {
        console.warn('Bin sans coordonn√©es:', bin.id);
        return;
      }

      const lat = parseFloat(bin.latitude);
      const lng = parseFloat(bin.longitude);

      if (isNaN(lat) || isNaN(lng)) {
        console.warn('Coordonn√©es invalides pour bin:', bin.id);
        return;
      }

      const latlng = [lat, lng];
      const popupContent = createBinPopupContent(bin);
      const icon = getBinIcon(bin.garbageType);

      if (binMarkersById[bin.id]) {
        binMarkersById[bin.id]
          .setLatLng(latlng)
          .setPopupContent(popupContent);
      } else {
        const marker = L.marker(latlng, { 
          icon: icon,
          title: 'Poubelle - ' + (bin.garbageType || 'Type inconnu')
        })
          .bindPopup(popupContent);
        
        binMarkers.addLayer(marker);
        binMarkersById[bin.id] = marker;
      }
    }

    // ===== FONCTIONS DE CHARGEMENT =====
    
    function loadCollectCenters(centers) {
      if (!Array.isArray(centers)) {
        console.error('loadCollectCenters: centers doit √™tre un tableau');
        return;
      }

      // Vider les centres existants
      collectCenterMarkers.clearLayers();
      Object.keys(centerMarkersById).forEach(key => delete centerMarkersById[key]);
      
      let validCount = 0;
      centers.forEach(center => {
        if (center.latitude && center.longitude) {
          addCollectCenter(center);
          validCount++;
        }
      });

      console.log(`‚úÖ ${validCount} centres de collecte charg√©s`);
      adjustMapBounds();
    }

    function loadBins(bins) {
      if (!Array.isArray(bins)) {
        console.error('loadBins: bins doit √™tre un tableau');
        return;
      }

      // Vider les bins existants
      binMarkers.clearLayers();
      Object.keys(binMarkersById).forEach(key => delete binMarkersById[key]);
      
      let validCount = 0;
      bins.forEach(bin => {
        if (bin.latitude && bin.longitude) {
          addBin(bin);
          validCount++;
        }
      });

      console.log(`‚úÖ ${validCount} bins charg√©s`);
      adjustMapBounds();
    }

    // ===== GESTION DES FILTRES =====
    
    function toggleCenters(show) {
      showCenters = show;
      if (show) {
        map.addLayer(collectCenterMarkers);
      } else {
        map.removeLayer(collectCenterMarkers);
      }
      console.log('Centres de collecte:', show ? 'affich√©s' : 'masqu√©s');
    }

    function toggleBins(show) {
      showBins = show;
      if (show) {
        map.addLayer(binMarkers);
      } else {
        map.removeLayer(binMarkers);
      }
      console.log('Bins:', show ? 'affich√©s' : 'masqu√©s');
    }

    // ===== AJUSTEMENT DE LA VUE =====
    
    function adjustMapBounds() {
      const allBounds = [];
      
      if (showCenters) {
        collectCenterMarkers.eachLayer(marker => {
          allBounds.push(marker.getLatLng());
        });
      }
      
      if (showBins) {
        binMarkers.eachLayer(marker => {
          allBounds.push(marker.getLatLng());
        });
      }
      
      if (meMarker) {
        allBounds.push(meMarker.getLatLng());
      }
      
      if (allBounds.length > 0) {
        const bounds = L.latLngBounds(allBounds);
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
      }
    }

    // ===== GESTION DES MESSAGES DE REACT NATIVE =====
    
    function handleMessage(event) {
      try {
        const msg = JSON.parse(event.data);
        
        switch(msg.type) {
          case 'user_location':
            updateMe(msg.lat, msg.lng, msg.accuracy);
            break;
            
          case 'collect_centers':
            if (Array.isArray(msg.centers)) {
              loadCollectCenters(msg.centers);
            }
            break;
            
          case 'bins':
            if (Array.isArray(msg.bins)) {
              loadBins(msg.bins);
            }
            break;
            
          case 'toggle_centers':
            toggleCenters(msg.show);
            break;
            
          case 'toggle_bins':
            toggleBins(msg.show);
            break;
            
          case 'clear_all':
            collectCenterMarkers.clearLayers();
            binMarkers.clearLayers();
            Object.keys(centerMarkersById).forEach(key => delete centerMarkersById[key]);
            Object.keys(binMarkersById).forEach(key => delete binMarkersById[key]);
            break;
            
          default:
            console.log('Message type inconnu:', msg.type);
        }
      } catch(e) {
        console.error('Erreur parsing message:', e);
      }
    }

    // √âcouter les messages (compatibilit√© iOS/Android)
    window.addEventListener('message', handleMessage);
    document.addEventListener('message', handleMessage);

    console.log('‚úÖ Carte Leaflet initialis√©e avec support bins et centres');
  </script>
</body>
</html>